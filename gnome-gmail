#!/usr/bin/python -tt
#
# Copyright 2011-2014 David Steele <dsteele@gmail.com>
# This file is part of gnome-gmail
# Available under the terms of the GNU General Public License version 2 or later
#
""" gnome-gmail
This script accepts an argument of a mailto url, and calls up an appropriate
GMail web page to handle the directive. It is intended to support GMail as a
GNOME Preferred Email application """

import sys
import urlparse
import urllib
import webbrowser
import imaplib
import os
import re


from email import encoders
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import mimetypes

from gi.repository import Gtk

import locale
import gettext
import string
import json

from ConfigParser import SafeConfigParser
import os
import os.path

locale.setlocale( locale.LC_ALL, '' )
gettext.textdomain( "gnome-gmail" )
_ = gettext.gettext


import dbus

import webkit
import gobject
import random


class GGError( Exception ):
    """ Gnome Gmail exception """
    def __init__(self, value ):
        self.value = value
        super( GGError, self).__init__()

    def __str__( self ):
        return repr( self.value )

class GMOauth():
    """oauth mechanism per
          https://developers.google.com/accounts/docs/OAuth2InstalledApp
        example at
          http://google-mail-oauth2-tools.googlecode.com/svn/trunk/python/oauth2.py
        Eg:
          (access, refresh) = GMOauth().generate_tokens( "user@gmail.com" )
    """

    def __init__(self):
        self.auth_endpoint = "https://accounts.google.com/o/oauth2/auth"
        self.token_endpoint = "https://accounts.google.com/o/oauth2/token"
        self.client_id = "284739582412.apps.googleusercontent.com"
        self.client_secret = "EVt3cQrYlI_hZIt2McsPeqSp"
        self.win_valid = None


    def get_code(self, login_hint):
        s=string.lowercase + string.uppercase + string.digits
        state = ''.join(random.sample(s,10))

        gobject.threads_init()
        win = gtk.Window()
        win.set_title("")
        bro = webkit.WebView()

        args = { "response_type": "code",
             "client_id": self.client_id,
             "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
             "prompt": "consent",
             #"scope": "openid email https://mail.google.com/",
             "scope": "https://mail.google.com/",
             "state": state,
             "login_hint": login_hint }

        code_url= "%s?%s" % (self.auth_endpoint, urllib.urlencode(args))

        bro.open(code_url)
        win.add(bro)
        win.resize(600,600)

        self.win_valid=True
        def win_closed(window, self):
           self.win_valid = False
        win.connect("destroy", win_closed, self)

        win.show_all()

        code = None
        while self.win_valid:
            gtk.main_iteration_do(False)
            bro_title = bro.get_title()
            if bro_title and state in bro_title:
                code = bro_title.split("=")[-1]
                if not win.emit("delete-event", gtk.gdk.Event(gtk.gdk.DELETE)):
                    win.destroy()

        return code

    def get_token_dict(self, code):

        args = { "code": code,
             "client_id": self.client_id,
             "client_secret": self.client_secret,
             "redirect_uri": "urn:ietf:wg:oauth:2.0:oob",
             "grant_type": "authorization_code",
           }

        token_page = urllib.urlopen( self.token_endpoint, urllib.urlencode(args))

        return(json.loads(token_page.read()))

    def get_access_from_refresh(self, refresh_token):

        args = { "refresh_token": refresh_token,
             "client_id": self.client_id,
             "client_secret": self.client_secret,
             "grant_type": "refresh_token",
          }

        token_page = urllib.urlopen( self.token_endpoint, urllib.urlencode(args))
        token_dict = json.loads(token_page.read())

        if "access_token" in token_dict:
            return(token_dict["access_token"])
        else:
            return(None)

    def generate_tokens(self, login, refresh_token=None):
        """Generate an access token/refresh token pair for 'login' email
           account, using an optional refresh token.
           If refresh is not possible, the caller will be prompted for
           authentication via an internal browser window."""

        if refresh_token:
           access_token = self.get_access_from_refresh(refresh_token)
           if access_token:
               return( (access_token, refresh_token) )

        code = self.get_code(login)

        token_dict = self.get_token_dict(code)

        try:
            return( (token_dict["access_token"], token_dict["refresh_token"]) )
        except:
            # todo - replace with a GG exception
            return( (None, None) )




class GmailIMAP4_SSL( imaplib.IMAP4_SSL ):
    def __init__( self, host = 'imap.gmail.com',
                        port = imaplib.IMAP4_SSL_PORT,
                        keyfile = None,
                        certfile = None):

        imaplib.IMAP4_SSL.__init__( self, host, port, keyfile, certfile )

        imaplib.Commands['XLIST'] = ('AUTH', 'SELECTED')
        imaplib.Commands['ID'] = ('AUTH')

    def xlist(self, directory='""', pattern='*'):
        """List mailbox names in directory matching pattern.

        (typ, [data]) = <instance>.xlist(directory='""', pattern='*')

        'data' is list of XLIST responses.

        https://developers.google.com/google-apps/gmail/imap_extensions
        #extension_of_the_list_command_xlist
        """
        name = 'XLIST'
        typ, dat = self._simple_command(name, directory, pattern)
        return self._untagged_response(typ, dat, name)

    def special_folders( self ):
        """ return a dictionary of localized Gmail special folders """
        path = {}

        for entry in self.xlist()[1]:
            for name in ("Inbox", "Starred", "Sent", "Drafts",
                         "Spam", "AllMail"):
                if re.search( ' .%s\)' % name, entry ):
                    path[ name ] = re.search( '\"([^\"]+)\"$', entry).group(1)

        return path

    def id( self, *args ):
        """ Provide app information to the server, 
            and get information in return (RFC2971)"""
        arg = '("' + '" "'.join( args ) + '")'
        name = 'ID'
        typ, dat = self._simple_command( name, arg )
        return self._untagged_response(typ, dat, name)

    def uid2msgid( self, uid ):
        """ Convert an IMAP UID to a Gmail MSGID

        http://code.google.com/apis/gmail/imap/#
        #access_to_the_gmail_unique_message_id_x-gm-msgid"""

        typ, data = self.uid( r'fetch', uid, r'(X-GM-MSGID)')

        msgid_dec = re.search( r'X-GM-MSGID ([0-9]+)', data[0] ).group(1)
        msgid_hex = hex( int( msgid_dec ) )

        return msgid_hex[2:]


class GMailIMAP( ):
    """ Handle mailto URLs that include 'attach' fields by uploading the 
    messages using IMAP """

    def __init__( self, mail_dict  ):
        self.mail_dict = mail_dict


    def form_message( self ):
        """ Form an RFC822 message, with an appropriate MIME attachment """

        msg = MIMEMultipart()

        for header in ( "To", "Cc", "Bcc", "Subject" ):
            if header.lower() in self.mail_dict:
                msg[ header ] = self.mail_dict[ header.lower() ][0]

        fname = os.path.split( self.mail_dict[ "attach" ][0] )[1]
        
        if "subject" not in self.mail_dict:
            msg[ "Subject" ] = _("Sending %s") % fname

        msg.preamble = _("Mime message attached")

        for filename in self.mail_dict[ 'attach' ]:
            attachment = self.file2mime( filename )
            msg.attach( attachment )

        self.message_text = msg.as_string()

    def file2mime( self, filename ):
        if( filename.find( "file://" ) == 0 ):
            filename = filename[7:]

        filepath = urlparse.urlsplit( filename ).path

        if not os.path.isfile( filepath ):
            raise GGError( "File not found - %s" % filepath )

        ctype, encoding = mimetypes.guess_type( filepath )

        if ctype is None or encoding is not None:
            ctype = 'application/octet-stream'

        maintype, subtype = ctype.split( '/', 1 )

        attach_file = open( filepath, 'rb' )

        if maintype == 'text':
            attachment = MIMEText( attach_file.read(), _subtype = subtype )
        elif maintype == 'image':
            attachment = MIMEImage( attach_file.read(), _subtype = subtype )
        elif maintype == 'audio':
            attachment = MIMEAudio( attach_file.read(), _subtype = subtype )
        else:
            attachment = MIMEBase( maintype, subtype )
            attachment.set_payload( attach_file.read() )
            encoders.encode_base64( attachment )

        attach_file.close()

        attachment.add_header( 'Content-Disposition', 'attachment',
            filename=os.path.split( filename )[1] )

        return( attachment )

    def _has_attachment( self ):

        return( 'attach' in self.mail_dict )

    def needs_imap( self ):

        return( self._has_attachment() )

    def send_mail( self, user, password ):
        """ transfer the message to GMail Drafts folder, using IMAP.
        Return a message ID that can be used to reference the mail via URL"""

        imap_obj = GmailIMAP4_SSL( )

        imap_obj.login( user, password )

        # identify the client per http://code.google.com/apis/gmail/imap/
        imap_obj.id(
              "name", "gnome-gmail",
              "version", "1.8.2",
              "os", "Linux",
              "contact", "dsteele@gmail.com",
              "support-url", "https://github.com/davesteele/gnome-gmail/issues",
              )

        try:
            # I may need this again someday
            folder_name = _("Drafts")

            # Find the localized Drafts folder
            error_exp = _("Unable to determine IMAP Drafts folder location")
            draft_folder = imap_obj.special_folders()['Drafts']

            # upload the message to the Drafts folder
            error_exp = _("Error encountered while uploading the message")
            append_resp = imap_obj.append( draft_folder, None, None, self.message_text )
            # the append returns e.g. ('OK', ['[APPENDUID 9 3113] (Success)'])
            # get the uid (e.g. 3113), and convert to Gmail ID to return

            error_exp = _("Error accessing message. Check the Drafts folder")
            msg_uid = re.search( r'UID [0-9]+ ([0-9]+)', append_resp[1][0]).group(1)

            imap_obj.select( draft_folder )
            msgid = imap_obj.uid2msgid( msg_uid )

        except (imap_obj.error, OSError):
            imap_obj.logout()
            raise GGError( error_exp )

        imap_obj.logout()

        return( msgid )


class GMailURL( ):
    """ Logic to convert a mailto link to an appropriate GMail URL, by
    any means necessary, including IMAP uploads, if necessary """

    def __init__( self, mailto_url, from_address, enable_net_access = True ):
        self.mailto_url = mailto_url
        self.enable_net_access = enable_net_access
        self.from_address = from_address

        self.mail_dict = self.mailto2dict( )


    def append_url( self, tourl, urltag, maildict, dicttag ):
        """ Given a GMail URL underconstruction and the URL tag for the
        current mailto dicttag, add the parameter to the URL """

        if dicttag in maildict:
            tourl = tourl + "&" + urltag + "=" + \
                urllib.quote_plus( maildict[dicttag][0] )

        return( tourl )


    def mailto2dict( self ):
        """ Convert a mailto: reference to a dictionary containing the 
        message parts """
        # get the path string from the 'possible' mailto url
        usplit = urlparse.urlsplit( self.mailto_url, "mailto" )

        path = usplit.path

        try:
            # for some reason, urlsplit is not splitting off the 
            # query string.
            # do it here
            # ( address, qs ) = string.split( path, "?", 1 )
            ( address, query_string ) = path.split( "?", 1 )
        except ValueError:
            address = path

            query_string = usplit.query

        qsdict = urlparse.parse_qs( query_string )

        qsdict['to'] = [ address ]

        if 'attachment' in qsdict:
            qsdict['attach'] = qsdict['attachment']

        outdict = {}
        for (key, value) in qsdict.iteritems():
            for i in range(0, len(value)):
                if key.lower() in [ 'to', 'cc', 'bcc' ]:
                    value[i] = urllib.unquote( value[i]  )
                else:
                    value[i] = urllib.unquote_plus( value[i]  )


            outdict[ key.lower() ] = value

        return( outdict )

    def standard_gmail_url( self ):
        """ If there is no attachment reference, create a direct GMail 
        URL which will create the message """

        dct = self.mail_dict

        tourl = "https://mail.google.com/mail/b/%s?view=cm&tf=0&fs=1" % \
                self.from_address

        tourl = self.append_url( tourl, "to", dct, "to" )
        tourl = self.append_url( tourl, "su", dct, "subject" )
        tourl = self.append_url( tourl, "body", dct, "body" )
        tourl = self.append_url( tourl, "cc", dct, "cc" )
        tourl = self.append_url( tourl, "bcc", dct, "bcc" )

        return( tourl )

    def simple_gmail_url( self ):
        """ url to use if there is no mailto url """

        return( "https://mail.google.com/mail/b/%s" % self.from_address )

    def imap_gmail_url( self ):
        """ if the mailto refers to an attachment, 
        use IMAP to upload the file """

        imap_url = "https://mail.google.com/%smail/#drafts/" % self.appsdomainstr

        if not self.enable_net_access:
            return( imap_url )

        try:
            gm_imap = GMailIMAP( self.mail_dict )
            gm_imap.form_message()
        except (imaplib.IMAP4.error, OSError):
            GGError( _("Error creating message with attachment") )

        # if we have a full set of configuration information, 
        # go ahead and try the transfer
        if True:
#        if( self.config_info.info_complete() ):
            try:
#                msg_id = gm_imap.send_mail( self.config_info.user, \
                msg_id = gm_imap.send_mail( self.from_address, \
#                    self.config_info.password )
                    "dummypassword" )
            except (imaplib.IMAP4.error, OSError) as inst:
                # don't report this failure. 
                # We'll try again with prompted parameters
                pass
            else:
                return( imap_url + msg_id )

        # query for needed information
        if( self.config_info.query_config_info() ):
            # do the IMAP upload
            try:
#                msg_id = gm_imap.send_mail( self.config_info.user, \
                msg_id = gm_imap.send_mail( self.from_address, \
                    "dummy poassword" )
            except (OSError, imaplib.IMAP4.error) as inst:
                error_str = None
                if inst.args[0].find( _("nvalid credentials") ) > 0:
                    error_str = _("Invalid GMail User Name or Password")
                elif inst.args[0].find( _("not enabled for IMAP") ) > 0:
                    error_str = _("You must 'Enable IMAP' in Gmail in order to send attachments")
                else:
                    error_str = inst.args[0]

                raise GGError( error_str )

            #self.config_info.write_config()
        else:
            raise GGError( _("GMail credentials incomplete") )

        return( imap_url + msg_id )

    def gmail_url( self ):
        """ Return a GMail URL appropriate for the mailto handled 
        by this instance """
        if( len( self.mailto_url ) == 0 ):
            gmailurl = self.simple_gmail_url() 
        elif GMailIMAP(self.mail_dict).needs_imap():
            gmailurl = self.imap_gmail_url()
        else:
            gmailurl = self.standard_gmail_url( )

        return( gmailurl )


def getFromAddress(last_address, gladefile):
    class Handler:
        def __init__(self, fromInit):
            self.txtbox = builder.get_object("entryFrom")
            self.txtbox.set_activates_default(True)

            self.txtbox.set_property("text", fromInit)

            self.txt = None

        def onOkClicked(self, button ):
            self.txt = self.txtbox.get_property("text")
            Gtk.main_quit()

        def onCancelClicked(self, button):
            self.txt = None
            Gtk.main_quit()

        def onUserSelClose(self, foo):
            self.onCancelClicked(foo)

    builder = Gtk.Builder()
    builder.add_from_file(gladefile)

    hdlr = Handler(last_address)
    builder.connect_signals(hdlr)

    builder.get_object("user_select_dialog").show_all()

    Gtk.main()

    return hdlr.txt

def getGoogleFromAddress(last_address, gladefile):
    retval = getFromAddress(last_address, gladefile)

    if retval and not re.search('@', retval):
        retval += "@gmail.com"

    return retval

class GgConfig(SafeConfigParser):
    def __init__(self, *args, **kwargs):

        self.fpath = os.path.expanduser(kwargs['fpath'])
        kwargs.pop('fpath', None)

        self.section = kwargs['section']
        kwargs.pop('section', None)

        initvals = kwargs['initvals']
        kwargs.pop('initvals')

        SafeConfigParser.__init__(self, *args, **kwargs)

        self.add_section(self.section)

        for option in initvals:
            self.set(self.section, option, initvals[option])

        self.read(self.fpath)
        self.save()

    def save(self):
        dir = os.path.dirname(self.fpath)

        if not os.path.exists(dir):
            os.makedirs(dir)

        with open(self.fpath, 'w') as fp:
            fp.write("# Automatically updated file - comments stripped\n")
            self.write(fp)

    def _saveit(fp):
        def wrapper(inst, *args, **kwargs):
            retval = fp(inst, *args, **kwargs)
            inst.save()
            return retval
        return wrapper

    def get_str(self, option):
        return self.get(self.section, option)

    @_saveit
    def set_str(self, option, value):
        return self.set(self.section, option, value)

    def get_bool(self, option):
        return self.getboolean(self.section, option)

    @_saveit
    def set_bool(self, param, val):
        if isinstance(val, bool):
            val = '1' if val else '0'
        return self.set(self.section, param, val)



def main( ):
    """ given an optional parameter of a valid mailto url, open an appropriate
    gmail web page """

    if( len( sys.argv ) > 1 ):
        mailto = sys.argv[1]
    else:
        mailto = ""

    config = GgConfig(fpath = "~/.config/gnome-gmail/gnome-gmail.conf",
                      section = 'gnome-gmail',
                      initvals = {
                                     'suppress_preferred': '0',
                                     'last_email': '',
                                 }
                      )

    # set this app as the GNOME mailto handler, new-style
#    [ app.set_as_default_for_type( "x-scheme-handler/mailto" )
#      for app in gio.app_info_get_all_for_type( "x-scheme-handler/mailto" )
#      if app.get_id() == "gnome-gmail.desktop" ]

    # quiet mode, to set preferred app in postinstall
    if( len( sys.argv ) > 1 and sys.argv[1] == "-q" ):
        sys.exit(0)

    sessionbus = dbus.SessionBus( )
    notifications_object = sessionbus.get_object(
        'org.freedesktop.Notifications',
        '/org/freedesktop/Notifications')
    interface = dbus.Interface(
        notifications_object,
        'org.freedesktop.Notifications')

    # for reverse compatibility, also set the preferred app the old way
#    cfg.query_set_preferred()

    glade_file = sys.prefix + "/share/gnome-gmail/gnomegmail.glade"
    last_from = config.get_str('last_email')
    from_address = getGoogleFromAddress(last_from, glade_file)
    if from_address:
        config.set_str('last_email', from_address)
    else:
        interface.Notify( "gnome-gmail", 0, '', "gnome-gmail", \
            _("User cancelled"), [], {}, 3000 )
        sys.exit(0)

    try:
        gm_url = GMailURL( mailto, from_address )
        gmailurl = gm_url.gmail_url()
    except GGError as gerr:
        interface.Notify( "gnome-gmail", 0, '', "gnome-gmail", \
            gerr.value, [], {}, 3000 )
    else:
        webbrowser.open_new_tab( gmailurl )

if __name__ == "__main__":
    main()



